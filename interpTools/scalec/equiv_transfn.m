function [a, f,P2, dP2, aid, epsi] = equiv_transfn(x, filtername);% return the equivalent kernel of a particular smoother% assume that distance is already normalized so smoother lives on -1 1%% [a, f,P2, dP2] = equiv_transfn(x, filtername);% % Input%   x, the nxm location of the data- repeated indices not handled well%   (ignored)%   filtername, the name of a filter to analyze:%      'quadloess'%      'linloess'%      'hanning'%      'boxcar'% % Output%   a, the equivalent kernel for the data (can be used to make estimate:%   z^=a'*zo%   f, the frequency scale%   P2, the squared equivalent transfer function%   dP2, the squared error between ETF and ideal filter%   aid, the indices into the non-zero filter weights, which can be%   convolved against obs%   (note, normalize the weights first garuntee proper mapping)%   epsi, the percentage of variance (noise or other) passed% convert input to radial[N,m] = size(x);r = sqrt(sum(x.^2,2));aid = find(r<=1);r = r(aid);x = x(aid,:);N = length(aid);if(N<1)    return;end% compute the transfer function with on this grid in all dim.DX = 0.1; % controls Nyquist = 1/2DX (0.1)%DX = 0.25*1/12; % controls Nyquist = 1/2DX (0.1)DX = 1/(2*10); % controls Nyquist = 1/2DX (0.1)DX = 1/(2*6); % controls Nyquist = 1/2DX (0.1)DLX = 10; % controls resolution = 1/DLX (5)% get the smoother at adequate resolutionDR = 1e-3; % need only resolve the continous kernel functionri = [0:DR:(max(r)+DR)]';ni = length(ri);% do the right thing for the right nameswitch filternamecase 'quadloess'    ai = loess_kernel([ri,zeros(ni,m-1)],2);    FC = 0.7; % here is the half-power pointcase 'linloess'    ai = loess_kernel([ri,zeros(ni,m-1)],1);    FC = 0.4; % here is the half-power pointcase 'hanning'    ai = hanning_wt(ri);    FC = 0.4; case 'boxcar'    ai = ones(length(ri),1);    FC = 0.25;otherwise    return;end%plot(ri, ai)%fpause% we could re-use this result% interpolate to the data to get equiv. kerneltica = zeros(N,1);a = interp1(ri,ai, r, 'linear*');%a = a/sum(a);%plot(r,a)%fpause% compute via fft on a equally spaced grid to get equiv. trans. fn.xi = -DLX:DX:DLX;ni = length(xi);im = sqrt(-1);DF = 1/((ni-1)*DX);% get f-resolutionFN = 1/(2*DX); % get Nyquist fNF = 1+(ni-1)/2;  % ALWAYS ODD NUMBER OF ELEMENTS, get one sidedf = [0:DF:FN]';% init arrays and find input-output mapping indicesswitch mcase 1    ai = zeros(ni,1); % init array    P = ai;    id = 1+round((x(:,1)-xi(1))/DX); % find indicescase 2     ai = zeros(ni,ni);    P = ai;    id1 = 1+round((x(:,1)-xi(1))/DX);    id2 = 1+round((x(:,2)-xi(1))/DX); % xi is 1-dim, same for all dim    id = (id1-1)*ni + id2;otherwise    error('can''t handle 3 d')end% search for repeated indicesatmp = a;idtmp = id;n_rep = length(atmp);while(n_rep>0)    % sort index into the regular array    [idtmp, sort_id] = sort(idtmp); % what nice use of variable names    atmp = atmp(sort_id); % arrange the inputs accordingly    notrep = ones(n_rep,1);    %notrep(1:(N-1)) =  [id(1:(N-1))~=id(2:N)]; % not repeated, including    %last    notrep(1:(n_rep-1)) =  [idtmp(1:(n_rep-1))~=idtmp(2:n_rep)]; % not repeated, including last    ai = 0*ai; % clear the output array    idnotrep = find(notrep);    ai(idtmp(idnotrep)) = atmp(idnotrep); % add data    P = P + fftn(ai); % transform    atmp = atmp(~notrep); % retain repeated values    idtmp = idtmp(~notrep);    n_rep = length(idtmp)endai(id) = a; % need this for nice plot% interesting paradox: %    an extra sample leads to no smoothing, and a white spectrum is passed by it, %    which damages the output spectrum.  However, noise is beat down by 1/N and%    noise passed is reduced by available smoothing. %    So, total noise is noise, in passbands.  What is error?%    At each f, the replicates give realizations of Fnoise(f) = complex coeff%    These are random variables with zero mean and var = df*(sigma_e^2)/(2*s0)%    Thus, the error of the summed, filtered observations should be weighted average%    where the expected noise variance passed is 1/weight%    <z> = sum z^ (1/noise^)%% get 1 sideP = P/P(1); % normalize so mean value is 1if(m==1)    P = P(1:NF);elseif(m==2)    % get upper half and center spectrum    P = [P(1:NF, (NF+1):end), P(1:NF, 1:NF)];endP2 = P.*conj(P); % normalized variance passed% rotate to x=0;theta = 2*pi*f*(DLX);if(m==1)    P = P.*exp(im*theta);    fabs = f;elseif(m==2)    fx = [(-FN):DF:FN]'; % need full frequency range    thetax =  2*pi*fx*(DLX);    [thetax,thetay] =  meshgrid(thetax,theta);    P = P.*exp(im*(thetax + thetay));    [fx,fy] = meshgrid(fx,f);    fabs = sqrt(fx.^2 + fy.^2);    f=fx+im*fy; % store the axes this wayend% here is the ideal filterPL = (fabs<FC);% here is discrepancy, including phasedP = PL-P;dP2 = (dP.*conj(dP)); % normalized error variancefprintf('%.2e seconds for calculating transform of kernel\n', toc);% displayif(m==1)    c = 'r';    subplot 211    plot(xi,N*ai,[c,'.'], x,N*a, c)    ylabel('equiv. kernel')    grid on    subplot 212    semilogy(f,[P2],[c,'-'], f,dP2, [c,'--'], f, cumsum(dP2)/(FC/DF), [c,'.'])    xlabel('f')    ylabel('Power')    title(sprintf('f_c=%.2f, \\Deltaf=%.2f', FC, DF))    legend('P', '\DeltaP', 'integral \DeltaP',3)    % you can show that there is a phase shift too:    %figure    %plot(f, angle(P))elseif(m==2)    subplot 221    imagesc(xi,xi,ai); axis([-1 1 -1 1]); axis xy; colorbar    hold on    plot(x(:,1), x(:,2), '.m')    hold off    title('equiv. kernel')    subplot 222    imagesc(fx(1,:), fy(:,1) ,P2); axis xy; colorbar    title('equiv. trans. funct.')    subplot 223    imagesc(fx(1,:), fy(:,1), dP2); axis xy; colorbar    title('error trans. funct.')    xlabel('f_x = cycles/\lambda_x')    ylabel('f_y = cycles/\lambda_y')    subplot 224    imagesc(fx(1,:), fy(:,1), (DF.^2)*cumsum(cumsum(dP2)')'); axis xy; colorbar    title('cum. etf')end% percentage of variance passedepsi=ai/sum(ai); epsi = (epsi'*epsi);break% run this wayx = [-1:.1:1]';[X,Y] = meshgrid(x,x);[a, f,P2, dP2] = equiv_transfn([X(:),Y(:)], 'quadloess');figure(gcf)% percentage of variance passed% get percentage of variance passed by 2-sided spectrumepsi = (sum(P2(:)) + sum(P2(2:end)))/(2*length(P2)-1)% this is the same as the varianced passed by the normalized filter weightsepsi=ai/sum(ai); epsi = (epsi'*epsi)