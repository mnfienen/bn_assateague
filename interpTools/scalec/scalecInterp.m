function [zi, msei, nmsei, msri] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol, WB);% [zi, msei, nmsei, msri] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol, WB);% % This is a stand-alone general purpose interpolator. % It remvoes a linear (or planar) trend first and then calls scalecInterpPerturbations %% Input%   x, the nxm location of the data- repeated indices not handled well (ignored)%   z, the observations%   s, the the observation errors (i.e., standard deviations, rms, etc.)%      s is used to weight the observations as 1/s%      choose s=0 if no information is available about the weights %   xi, the interpolation locations%   lx, the interpolation weighting length scales%   filtername, the name of a filter to analyze:%      'quadloess'%      'linloess'%      'hanning'%      'boxcar'%   nmseitol, a maximum error level, if exceeded causes doubling of smoothing scales%       NOTE: if nmseitol=1 then this means we accept result with input scales%             if nmseitol<1 then this means interpolation will successive doubling of scales to reach desired noise reduction%   WB, a flag to use the waitbar to show progress. WB=1 will show waitbar, missing,empty, or other value won't% % Output%   zi, the estimate%   msei, the mean square interpolation error estimate (units of z)%   nmsei, the normalized mean square error%   msri, the mean square residuals% fix up input data[Ni,mi] = size(xi);[N,m] = size(x);% check waitbar flagif(~exist('WB'))    WB = [];elseif(WB~=1)    WB = [];end% check for output error maximumif(~exist('nmseitol'))    nmseitol = inf; % never invoke toleranceend    % deal with nansif(length(s)==1)    s = repmat(s,N,1);endid = find(isfinite(sum([x,z,s],2)));x=x(id,:);z = z(id);s = s(id);if(length(lx)==N & length(lx)~=Ni)    % got to remove the corresponding scales    lx = lx(id,:);end[N,m] = size(x);% need to remove trend once, % first, shift and scale grid and datamean_xi = mean(xi,1); % center on output centerx = x - repmat(mean_xi, N,1);xi = xi - repmat(mean_xi, Ni,1);std_x = std(x);id =find(std_x==0);if(length(id)>0) % catch variables with zero variance (e.g., a profile)    std_x(id) = 1+0*id;endL = diag(1./std_x);x = x*L;xi = xi*L;lx = lx*L;% need some consistent weightswtol = 0.01;[wt, var_z] = consistentWeight(z, s.^2, wtol);% do regression to remove a norm fieldbtrend = zeros(mi+1,1);bi = btrend;% only compute against variables with variancevarid = find(std_x>0);if(length(varid>0))    % this is just for getting the data ready, so it is meant to be bullet proof, not statistically pure!    [btrend([1,varid+1]),bi([1,varid+1])] = regr_xzw([ones(N,1),x(:,varid)], z, wt);    fprintf('removed order %d polynomial\n', 1);end% regression failed if nanif(any(isnan(btrend)))    % pad with zero    btrend = zeros(length(btrend),1);endztrend = [ones(N,1),x]*btrend;% compute deviations from trendz = z - ztrend;% pass the trend-removed data to scalecInterpPerturbations[zi, msei, nmsei, msri] = scalecInterpPerturbations(x, z, s, xi, lx, filtername, nmseitol,Ni,0,WB);% compute trend on data locationsztrend = [ones(Ni,1),xi]*btrend;% replace trendzi=zi+ztrend;