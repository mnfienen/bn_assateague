function [ZI, MSEI, NMSEI, MSRI] = scalecInterpTilePerturbations(x, z, s, xi, lx, filtername, nmseitol, WB);% [ZI, MSEI, NMSEI, MSRI] = scalecInterpTilePerturbations(x, z, s, xi, lx, filtername, nmseitol, WB);%% optimize interpolation for regular grid output by breaking into bite-sized tiles% which are passed to scalecInterpPerturbations (which does not remove any trend)%% Input%   x, the nxm location of the data- repeated indices not handled well (ignored)%   z, the observations%   s, the the observation errors (i.e., standard deviations, rms, etc.)%      s is used to weight the observations as 1/s%      choose s=0 if no information is available about the weights%   xi, the interpolation locations%   lx, the interpolation weighting length scales%   filtername, the name of a filter to analyze:%      'quadloess'%      'linloess'%      'hanning'%      'boxcar'%   nmseitol, a maximum error level, if exceeded causes doubling of smoothing scales%       NOTE: if nmseitol=1 then this means we accept result with input scales%             if nmseitol<1 then this means interpolation will successive doubling of scales to reach desired noise reduction%   WB, a flag to use the waitbar to show progress. WB=1 will show waitbar, missing,empty, or other value won't%% Output%   zi, the estimate%   msei, the mean square interpolation error estimate (units of z)%   nmsei, the normalized mean square error%   msri, the mean square residuals% change log% 12 Feb 2009, NGP,  disabled the figure display so large regions don't croak% catch  input% check request for waitbarif(~exist('WB'))    WB = 0;elseif(isempty(WB))    WB = 0;end% check dimensions[Ni,mi] = size(xi);if(~exist('nmseitol'))    %nmseitol = inf; % never invoke tolerance    nmseitol = 1./(mi^2); % default tol ensures some data used    fprintf('scalecInterpTile: setting maximum nmsei tolerance to %.3f\n', nmseitol)end% detect gridded dataidxi = find(xi(:,1)==xi(1,1));idyi = find(xi(:,2)==xi(1,2));% if second occurrance of x(1) coincides with end of occurrances of y(1), suspect gridded datatry    if((idyi(2)-1)==idxi(end))        fprintf('gridded output suspected\n');    endcatch    % no evidence for grid, must interpolate all at once    % send to stand-alone interp    fprintf('output not a 2-d grid\n')    [ZI, MSEI, NMSEI, MSRI] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol, WB);    return;endnyi = idxi(end);nxi = Ni/nyi;% modify to handle time input for single time output on 2-d-h gridif (nxi~=fix(nxi))    fprintf('indices not consistent with gridded output, continuing to interp\n')    % send to stand-alone interp    [ZI, MSEI, NMSEI, MSRI] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol,WB);    return;else    % we still think we have gridded data    Xi = reshape(xi(:,1),nyi,nxi);    Yi = reshape(xi(:,2),nyi,nxi);    % and we are requesting single time    if(mi==3 & all(xi(:,3)==xi(1,3)))        Ti = xi(1,3);    end    xitest = Xi(1,:);    yitest = Yi(:,1);    [Xitest, Yitest] = meshgrid(xitest,yitest);    % check carefully and pass to scalecInterp if fail    if(~all(Xi==Xitest & Yi==Yitest))        fprintf('inidices not consistent with gridded output, continuing to interp\n')        % send to stand-alone interp        [ZI, MSEI, NMSEI, MSRI] = scalecInterp(x, z, s, xi, lx, filtername, nmseitol, WB);        return;    endend% if we survived to here, we have gridded output% xi and yi are now row,col vectors of grid indicesxi = xitest;yi = yitest;clear xitest yitest Xitest Yitest% fix up input data[N,m] = size(x);% deal with nansid = find(isfinite(sum([x,z,s],2))); x=x(id,:);z = z(id);s = s(id);if(length(lx)==N & length(lx)~=Ni)    % got to remove the corresponding scales    if(all(size(lx)==size(x)))        fprintf('smoothing scales vary with data')        lx = lx(id,:);    endend[N,m] = size(x);% need to remove trend once,% first, shift and scale grid and data% shift, center on output centermean_xi = mean(xi);mean_yi = mean(yi);xi = xi - mean_xi;yi = yi - mean_yi;Xi = Xi - mean_xi;Yi = Yi - mean_yi;x(:,1) = x(:,1) - repmat(mean_xi, N,1);x(:,2) = x(:,2) - repmat(mean_yi, N,1);% scalestd_x = std(x);id =find(std_x==0);if(length(id)>0) % catch variables with zero variance (e.g., a profile)    std_x(id) = 1+0*id;endL = diag(1./std_x); x = x*L;xi = xi*L(1,1);yi = yi*L(2,2);Xi = Xi*L(1,1);Yi = Yi*L(2,2);lx = lx*L;% add timeif(mi==3)    Ti = Ti*L(3,3);end% need some consistent weightswtol = 0.01;try[wt, var_z] = consistentWeight(z, s.^2, wtol);catch    lasterr    keyboard    % if this dies, var_z = s.^2 is a nice guessend% sort out the lx inputif (length(lx(:))==mi)    % same everywhere    lxflag = 'constant';elseif(length(lx(:,1))==Ni)    lxflag = 'ongrid';    lxgrid = reshape(lx(:,1), nyi,nxi);    lygrid = reshape(lx(:,2), nyi,nxi);    if(mi==3)        ltgrid = reshape(lx(:,3),nyi,nxi);    endelse    % assume on data    lxflag = 'ondata';end% get optimal tile% first compute smoothness/domain size ratiolk=max([min(lx(:,1)), min(lx(:,2))]./[max(xi)-min(xi), max(yi)-min(yi)]);if(isnan(lk) | isinf(lk))    lk = 0;end% next, the optimal number of tileskopt = sqrt(nxi*nyi*(1+lk));ropt = (1/kopt) + kopt/((1+lk)*nxi*nyi);% number of tiles in x,y dims% kx = ceil(kopt/nyi); % proportion to grid dimensions% ky = ceil(kopt/kx);kx = ceil(sqrt(kopt)); % proportion to grid dimensionsky = ceil(kopt/kx);kopt = kx*ky;ropt = (1/kopt) + kopt/((1+lk)*nxi*nyi);% divide grid points per tile, roughlyif(kx==1)    nkx = nxi;else    nkx = fix(nxi/kx); % must round down    if(nkx<1)        nkx=1;        kx=nxi; % make sure we do them all    endendif(ky==1)    nky = nyi;else    nky = fix(nyi/ky);    if(nky<1)        nky=1;        ky = nyi;     endendfprintf('number of tiles = %d, expected effiency =%.2g, xi/tile=%d, yi/tile=%d\n',kopt, ropt, nkx,nky);% specify overlapLMAX = 10*[max(lx(:,1)),max(lx(:,2))];% init outputZI = nan*ones(nyi,nxi);NMSEI = ones(nyi,nxi);MSEI = ZI;MSRI = ZI;% beginNdone = 0;tstart = clock;tcheck = clock;for i=1:kx    idxi = [1:nkx] + (i-1)*nkx; % indices to interp this time    if(i==kx & idxi(end)~=nxi)        idxi = [idxi(1):nxi]; % catch the end here    end    % what is appropriate overlap?    xmin = xi(idxi(1))-LMAX(1); % find tile limits    xmax = xi(idxi(end))+LMAX(1);    idx = find(x(:,1)<xmax & x(:,1)>xmin); % get the useful data    if(length(idxi)>0)        % repeat at each yi        for j=1:ky            idyi = [1:nky] + (j-1)*nky; % indices to interp this time            if(j==ky & idyi(end)~=nyi)                idyi = [idyi(1):nyi]; % catch the end here            end            ymin = yi(idyi(1))-LMAX(2);            ymax = yi(idyi(end))+LMAX(2);            idxy = idx(find(x(idx,2)<ymax & x(idx,2)>ymin)); % get the useful data            if(length(idxy)>mi)                % send to interpolator                Xii = Xi(idyi,idxi);                Yii = Yi(idyi,idxi);                % deal with smoothing scales                switch lxflag                    case 'constant'                        L = lx;                    case 'ongrid'                        lxii = lxgrid(idyi,idxi);                        lyii = lygrid(idyi,idxi);                        L = [lxii(:), lyii(:)];                        if(mi==3)                            ltii = ltgrid(idyi,idxi);                            L = [L, ltii(:)];                        end                    case 'ondata'                        L = lx(idxy,:);                end                % now, send to interp                if(mi==2)                    % interp 2-d                    [zi, msei, nmsei, msri, WB] = scalecInterpPerturbations(x(idxy,:), z(idxy), s(idxy), [Xii(:), Yii(:)], L, filtername, nmseitol, Ni, Ndone, WB);                elseif(mi==3)                    % interp 2-d + time                    [zi, msei, nmsei, msri, WB] = scalecInterpPerturbations(x(idxy,:), z(idxy), s(idxy), [Xii(:), Yii(:), Ti+0*Xii(:)], L, filtername, nmseitol, Ni, Ndone, WB);                end                zi = reshape(zi, length(idyi), length(idxi));                msei = reshape(msei, length(idyi), length(idxi));                nmsei = reshape(nmsei, length(idyi), length(idxi));                msri = reshape(msri, length(idyi), length(idxi));                ZI(idyi,idxi) = zi;                MSEI(idyi,idxi) = msei;                NMSEI(idyi,idxi) = nmsei;                MSRI(idyi,idxi) = msri;                Ndone = Ndone + length(idyi)*length(idxi);                if(etime(clock,tcheck)>60)                    tcheck = clock;                    fprintf('progres: completed %d of %d points\n', Ndone,nyi*nxi);                end            end        end    endendtend = clock;fprintf('interpolated %d points per second (tiled)\n', fix(nyi*nxi/(etime(tend,tstart))))% return output in colsZI    = ZI(:);MSEI  = MSEI(:);NMSEI = NMSEI(:);MSRI  = MSRI(:);% fix up error tooid = find(isnan(MSEI));MSEI(id) = var_z + mean(s.^2);MSRI(id) = MSEI(id);% clean up any waitbars that we generatedif(WB>0)    f=findobj(allchild(0),'flat','Tag','TMWWaitbar');    if length(f)        close(f);    endend