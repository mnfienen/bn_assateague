function [Xi,zi, si, ni, Ji, Jmax, X0] = subsampleData(X,z,e,DX);% [Xi,zi, si, ni, Ji, Jmax, X0] = subsampleData(X,z,e,DX);%% interpolate data into regular sample bins using boxcar window%% Input%   X, an NxM set of coordinates%   z, an Nxr array of observations, where the 2:rth columns are averaged identically to the first column%   e, an Nx1 array of errors (used to weight sum) (optional)%      % ONLY APPLIES TO z(:,1), other variables (if exist) weighted by these values%   DX, an MxN2 array of scale parameters, indicating the step size in each dimension%     N2 is either 1 (indicating constant smoothing lengthscales, or M, indicating%     variable lengthscales for each datapoint%% Output%   Xi, the mean position of the data in each cell%   zi, the mean value at each interp. cell%   si, the standard error (=std. dev./sqrt(n)) (or, if ni<3, insert average value of all other si values)%      ONLY COMPUTED FOR z(:,1), others are weigthed identically%   ni, the number of observations going into each cell%   Ji, the array of indices into each cell%   Jmax, the array of number of cells in each dimension%   X0, the location of the first grid point (i.e., location at Ji=1)%      % to make a quick grid of the data:%      [XX,YY] = meshgrid([1:Jmax(1)]*DX(1)+X0(1),[1:Jmax(2)]*DX(2)+X0(2));%      ZZ = repmat(nan,Jmax(1),Jmax(2)); % careful, read in flipped%      EE = ZZ;%      ZZ(Ji) = zi; ZZ = ZZ'; % flip to usual orientation for matlab%      EE(Ji) = si; EE = EE'; %      pcolor(XX,YY,ZZ);% allow nans% 03 Jan 2011: ngp adds "+e+ so that data with nan error is chuckedid = find(~isnan(z+e));X = X(id,:);z = z(id);e = e(id);% 29jan2010- fails with nans!% id = find(~isnan(sum(X,2)));% X = X(id,:);% z = z(id);% e = e(id);% find out size of z (might have multiple columns[N,r] = size(z);[N,M] = size(X);% check to see if data errors were passed inif(nargin==3)    % need to pass e to DX and generate e    DX=e;    e = ones(N,1);end% what if constant error passed inif(length(e)==1);    % replicate and square it    e = zeros(N,1)+e^2;else    % just square it    e = e.^2;end% Turn error into a weightwtol = 0.1; % close enoughw = consistentWeight(z(:,1), e, wtol);% map data to scaled points% J = 1,1...,1 is location X0(1,1,...,1)X0 = floor(min(X)./DX).*DX; % make nice integer valuesJ = round(1+(X-repmat(X0,N,1))./repmat(DX,N,1));% map these to index into multi-D array of unique indicesJmax = max(J);Ji=ones(N,1);Jprod = 1;for i=1:M    Ji = Ji+(J(:,i)-1)*Jprod;    Jprod = Jprod*Jmax(i);end% sort them[Jisort,sortid] = sort(Ji);% how many unique?Ni = sum(diff(Jisort)>0) + 1;% initialize output arrays that are as large as the largest indexzi = repmat(0,Ni,r); % holds weighted sum, initiallyni = zeros(Ni,1); % number of observationswi = ni; % sum of weightsw2zi = ni; % weights against dataw2ei = ni; % weights against a priori errorsw2i = ni; % sum of squared weightssi = ni; % holds weighted sum of squares, initiallyJi = ni;Xi = repmat(0,Ni,M);% scan through observationscnt = 1;Ji(cnt) = Jisort(1);for i=1:N    % update the multi-d index and count    if(Jisort(i)>Ji(cnt))        cnt = cnt + 1;        Ji(cnt) = Jisort(i);    end        % sum values for this index    if (isfinite(z(sortid(i),1)))        ni(cnt) = ni(cnt) + 1;        wi(cnt) = wi(cnt) + w(sortid(i));        w2i(cnt) = w2i(cnt) + w(sortid(i))^2;        zi(cnt,:) = zi(cnt,:) + z(sortid(i),:)*w(sortid(i));        w2zi(cnt) = w2zi(cnt) + z(sortid(i),1)*(w(sortid(i))^2);        si(cnt) = si(cnt) + (z(sortid(i),1)*w(sortid(i)))^2;        w2ei(cnt) = w2ei(cnt) + e(sortid(i))*(w(sortid(i))^2);                % keep track of weighted mean data location within cell        Xi(cnt,:) = Xi(cnt,:) + X(sortid(i),:)*w(sortid(i));    endend% eliminate cases with missing data (e.g., nans)id = find(ni>0);ni = ni(id);% meanszi = zi(id,:)./repmat(wi(id), 1, r);Xi = Xi(id,:)./repmat(wi(id),1,M); % use this for mean data location in cell% mean square residualsi = (si(id) - 2*zi(:,1).*w2zi(id) + w2i(id).*(zi(:,1).^2))./ni;% return as mean square error (fraction of residual that passes through)si = si./(1+ni);% play usual trick to deal with cases where ni is smalln % weight computed residual by ni-1, and the a priori error variance by 1, sum of weights = ni% and return as square rootsi = sqrt( ((ni-1).*si + w2ei(id)./w2i(id))./ni );% finally, return indices into the virtual n-dimensional gridJi = Ji(id);  